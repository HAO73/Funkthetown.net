<template>
  <div class="container" :class="deviceClass">
    <!-- Message d'orientation supprim√© pour permettre le visionnage en portrait -->

    <video
      ref="backgroundVideo"
      muted
      playsinline
      :loop="false"
      preload="auto"
      class="background-video"
      @timeupdate="checkVideoEnd"
      @ended="handleVideoEnded"
      @play="onVideoPlay"
      @pause="onVideoPause" 
      @loadeddata="onVideoLoaded"
      @error="onVideoError"
    >
      <source :src="currentVideo" type="video/mp4" />
      Votre navigateur ne supporte pas la vid√©o HTML5.
    </video>
    <audio ref="backgroundAudio" class="background-audio" @play="onAudioPlay" @pause="onAudioPause" @ended="onAudioEnded">
      <source src="/MartinOne(MASTER (COM+EQ).wav" type="audio/wav" />
      Votre navigateur ne supporte pas l'audio HTML5.
    </audio>

    <div class="content">
      <p class="intro"><strong>Brother & Sister, Bienvenue...<br>
      We open our field, to the world.<br>
      To make it shine.</strong></p>
      <h2>Notre Vision</h2>
      <p>La vibration.<br>
      Pour nous la musique a une fonction sacr√©e dans le progr√®s humain.<br>
      Perdu au fil des ann√©es, nous proposons de reint√©grer sa puissance originelle.</p>
      <h2>Notre Mission</h2>
      <p>Cr√©e une plateforme d'interconnexion humaine via holochain et lancer les premiers<br>
      √©l√©ments sonores susceptibles de rassembler autour de la musique.</p>
     
      <div class="buttons-container">
        <button class="play-btn" @click="toggleMusic">
          <span v-if="!isPlaying">‚ñ∂Ô∏è Play</span>
          <span v-else>‚è∏Ô∏è Pause</span>
        </button>
        
        <a v-if="showUtopia" href="https://utopia.funkthetown.net" target="_blank" class="utopia-btn">Utopia</a>
      </div>
    </div>
  
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, computed } from 'vue';

const isPlaying = ref(false);
const showUtopia = ref(false);
const isMobile = ref(false);
// Variable isPortrait supprim√©e car plus n√©cessaire
const preloadedVideos = ref({});

// Pr√©charge les prochaines vid√©os pour un changement fluide
function preloadNextVideos(count) {
  for (let i = 0; i < count; i++) {
    const index = (currentVideoIndex.value + i) % videos.length;
    const videoPath = videos[index];
    
    // Ne pr√©charge que si ce n'est pas d√©j√† fait
    if (!preloadedVideos.value[videoPath]) {
      console.log(`Pr√©chargement de la vid√©o ${index}: ${videoPath}`);
      
      const preloadLink = document.createElement('link');
      preloadLink.rel = 'preload';
      preloadLink.href = videoPath;
      preloadLink.as = 'video';
      document.head.appendChild(preloadLink);
      
      // Marquer cette vid√©o comme pr√©charg√©e
      preloadedVideos.value[videoPath] = true;
    }
  }
}

// D√©tection des appareils mobiles uniquement (sans orientation)
const checkMobile = () => {
  const userAgent = navigator.userAgent || navigator.vendor || window.opera;
  isMobile.value = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
};

// Provide a responsive class based on device only
const deviceClass = computed(() => {
  return {
    'is-mobile': isMobile.value
    // Classes d'orientation supprim√©es pour permettre tous les formats
  };
});

// Initialiser
onMounted(() => {
  checkMobile();
  // Suppression des √©couteurs d'√©v√©nements d'orientation
  
  // S'assurer que la vid√©o est charg√©e mais ne d√©marre pas automatiquement
  if (backgroundVideo.value) {
    backgroundVideo.value.load();
    console.log("Vid√©o initiale charg√©e");
    
    // V√©rifier explicitement que la vid√©o n'est pas en boucle
    backgroundVideo.value.loop = false;
  }
  
  // √âcouter les erreurs pour faciliter le d√©bogage
  if (backgroundVideo.value) {
    backgroundVideo.value.addEventListener('error', (e) => {
      console.error('Erreur vid√©o:', e);
    });
  }
  
  if (backgroundAudio.value) {
    backgroundAudio.value.addEventListener('error', (e) => {
      console.error('Erreur audio:', e);
    });
  }
  
  // Pr√©charger les premi√®res vid√©os
  preloadNextVideos(3); // Pr√©charger les 3 premi√®res vid√©os
  
  // Ajouter un observateur pour v√©rifier si la source vid√©o change r√©ellement
  console.log("Source vid√©o initiale:", currentVideo.value);
});

// Nettoyer
onBeforeUnmount(() => {
  // Suppression des √©couteurs d'√©v√©nements d'orientation
});

const videos = [
  // Exemple de comment r√©f√©rencer des vid√©os externes
  // 'https://stockage-externe.com/videos/20231126_A740461.mp4',
  // En attendant, continuez √† utiliser les chemins locaux
  '/20231126_A740461_1.mp4',
  '/20231126_A740461_2.mp4',
  '/20231126_A740461_3.mp4',
  '/20231126_A740461_4.mp4',
  '/20231126_A740462k.mp4',
  '/20231126_A740463.mp4',
  '/20231126_A740464k_1.mp4',
  '/20231126_A740464k_2.mp4',
  '/20231126_A740465.mp4',
  '/20231126_A740466.mp4',
  '/20231126_A740467.mp4',
  '/20231126_A740468.MP4',
  '/20231126_A740469.MP4',
  '/20231126_A740470k.MP4',
  '/20231126_A740471.MP4',
  '/20231126_A740472.MP4',
  '/20231126_A740473.MP4',
  '/20231126_A740474.MP4',
  '/20231126_A740475.MP4',
  '/20231126_A740476.MP4',
  '/20231126_A740477.MP4',
  '/20231126_A740478.MP4',
  '/20231126_A740479.MP4',
  '/20231126_A740480.MP4',
  '/20231126_A740481.MP4',
  '/20231126_A740482.MP4',
  '/20231126_A740483.MP4',
  '/20231126_A740484.MP4',
  '/20231126_A740485.MP4',
  '/20231126_A740486.MP4',
  '/20231126_A740487.MP4',
  '/20231126_A740488.MP4',
  '/20231126_A740489.MP4',
  '/20231126_A740490.MP4',
  '/20231126_A740491.MP4',
  '/20231126_A740492.MP4',
  '/20231126_A740493.MP4',
  '/20231126_A740494.MP4',
  '/20231126_A740495.MP4',
  '/20231126_A740496.MP4',
  '/20231126_A740497.MP4',
  '/20231126_A740498.MP4',
 
];
const currentVideoIndex = ref(0);
const currentVideo = ref(videos[currentVideoIndex.value]);
const backgroundVideo = ref(null);
const backgroundAudio = ref(null);

// Cette fonction est maintenant utilis√©e pour forcer un changement manuel de vid√©o
function nextVideo() {
  console.log("Changement manuel de vid√©o demand√© par l'utilisateur");
  forceNextVideo();
}

function toggleMusic() {
  if (!backgroundAudio.value || !backgroundVideo.value) return;
  
  if (isPlaying.value) {
    // Pause l'audio et la vid√©o
    backgroundAudio.value.pause();
    backgroundVideo.value.pause();
    isPlaying.value = false;
  } else {
    // Si l'audio est termin√©, on le red√©marre depuis le d√©but
    if (backgroundAudio.value.ended) {
      backgroundAudio.value.currentTime = 0;
    }
    
    // Utilisation de Promise.all pour g√©rer les deux promesses de lecture
    const audioPlayPromise = backgroundAudio.value.play().catch(error => {
      console.log("Erreur de lecture audio:", error);
      return false;
    });
    
    const videoPlayPromise = backgroundVideo.value.play().catch(error => {
      console.log("Erreur de lecture vid√©o:", error);
      return false;
    });
    
    Promise.all([audioPlayPromise, videoPlayPromise])
      .then(() => {
        isPlaying.value = true;
      })
      .catch(error => {
        console.error("Erreur lors de la synchronisation:", error);
      });
  }
}

// Met √† jour l'√©tat si l'utilisateur utilise les contr√¥les natifs ou touche la fin
function onAudioPlay() {
  isPlaying.value = true;
  
  // Synchroniser la vid√©o avec l'audio si elle est en pause
  if (backgroundVideo.value && backgroundVideo.value.paused) {
    backgroundVideo.value.play().catch(error => {
      console.log("Erreur de lecture vid√©o:", error);
    });
  }
  
  // D√©marrer le timer pour le bouton Utopia
  setTimeout(() => {
    showUtopia.value = true;
  }, 72000); // 72 secondes pour l'apparition du bouton Utopia
}


function onAudioPause() {
  isPlaying.value = false;
  
  // Synchroniser la vid√©o avec l'audio
  if (backgroundVideo.value && !backgroundVideo.value.paused) {
    backgroundVideo.value.pause();
  }
}

function onAudioEnded() {
  // Afficher le bouton Utopia √† la fin de l'audio
  showUtopia.value = true;
  
  // Ne pas arr√™ter la vid√©o √† la fin de l'audio
  // La vid√©o continue de jouer, mais l'√©tat de lecture est consid√©r√© comme arr√™t√©
  isPlaying.value = false;
  
  console.log("Audio termin√©, vid√©o continue de jouer");
}

// Fonctions pour g√©rer les √©v√©nements de la vid√©o
function onVideoPlay() {
  // Synchroniser l'audio avec la vid√©o
  if (backgroundAudio.value && backgroundAudio.value.paused && !isPlaying.value) {
    backgroundAudio.value.play().catch(error => {
      console.log("Erreur de lecture audio dans onVideoPlay:", error);
    });
    isPlaying.value = true;
  }
}

function onVideoPause() {
  // Synchroniser l'audio avec la vid√©o, sauf lors du changement de vid√©o
  if (backgroundAudio.value && !backgroundAudio.value.paused && isPlaying.value) {
    backgroundAudio.value.pause();
    isPlaying.value = false;
  }
}

// G√©rer le chargement de la vid√©o
function onVideoLoaded() {
  // Ce gestionnaire d'√©v√©nements est utilis√© pour les chargements initiaux,
  // pas pour les transitions entre vid√©os qui sont g√©r√©es dans nextVideo()
  if (!backgroundVideo.value) return;
  
  console.log(`Vid√©o charg√©e: ${currentVideo.value}`);
  
  // V√©rifier si nous sommes au chargement initial de la page
  if (isPlaying.value && backgroundAudio.value && !backgroundAudio.value.paused) {
    backgroundVideo.value.play().catch(error => {
      console.log("Erreur lors de la lecture initiale:", error);
    });
  }
}

// Gestion explicite de la fin de la vid√©o
function handleVideoEnded() {
  console.log("üî¥ √âV√âNEMENT 'ENDED' D√âTECT√â");
  
  // Utiliser la fonction centralis√©e pour passer √† la vid√©o suivante
  forceNextVideo();
}

// V√©rifie si la vid√©o est presque termin√©e et pr√©pare la prochaine vid√©o avant la fin
function checkVideoEnd() {
  if (!backgroundVideo.value) return;
  
  const video = backgroundVideo.value;
  
  // Ajouter des logs plus fr√©quents pour d√©boguer
  if (Math.floor(video.currentTime) % 2 === 0 && video.currentTime > 0) {
    console.log(`Progression vid√©o: ${video.currentTime.toFixed(2)}/${video.duration.toFixed(2)}, Index actuel: ${currentVideoIndex.value}`);
  }
  
  // R√©duire la marge de d√©tection pour s'assurer de capturer la fin
  if (video.duration > 0 && 
      video.currentTime > 0 && 
      (video.currentTime > video.duration - 0.5 || video.ended) && 
      !video.paused) {
    
    console.log(`Fin de vid√©o d√©tect√©e - Temps actuel: ${video.currentTime.toFixed(2)}, Dur√©e: ${video.duration.toFixed(2)}`);
    
    // Force le passage √† la vid√©o suivante
    forceNextVideo();
  }
}

// Nouvelle fonction pour centraliser la logique de changement de vid√©o
function forceNextVideo() {
  // Cr√©er une r√©f√©rence √† l'ancien index pour d√©bogage
  const oldIndex = currentVideoIndex.value;
  const newIndex = (currentVideoIndex.value + 1) % videos.length;
  const oldSource = videos[oldIndex];
  const newSource = videos[newIndex];
  
  console.log(`CHANGEMENT DE VID√âO: ${oldIndex} -> ${newIndex}`);
  console.log(`SOURCE: ${oldSource} -> ${newSource}`);
  
  // S'assurer que nous ne sommes pas d√©j√† en train de charger la suivante
  if (currentVideo.value === newSource) {
    console.log("Cette vid√©o est d√©j√† en cours de chargement, abandon du changement");
    return;
  }
  
  // Enregistrer l'√©tat de lecture actuel
  const wasPlaying = isPlaying.value;
  
  // Mettre √† jour l'index et la source vid√©o
  currentVideoIndex.value = newIndex;
  currentVideo.value = newSource;
  
  // Pr√©charger les prochaines vid√©os
  preloadNextVideos(2);
  
  // Forcer le rechargement et la lecture de la vid√©o
  if (backgroundVideo.value) {
    // S'assurer que la vid√©o se recharge compl√®tement
    backgroundVideo.value.load();
    
    // Si l'utilisateur √©tait en train de regarder, relancer la lecture
    if (wasPlaying) {
      // Utiliser un court d√©lai pour s'assurer que la source est mise √† jour
      setTimeout(() => {
        if (backgroundVideo.value) {
          console.log(`Relance de la lecture pour la vid√©o ${newIndex}: ${newSource}`);
          
          // Fonction de callback appel√©e quand la vid√©o est charg√©e
          backgroundVideo.value.onloadeddata = () => {
            console.log(`Vid√©o ${newIndex} charg√©e, lancement de la lecture`);
            backgroundVideo.value.play().catch(error => {
              console.error("Erreur lors de la lecture de la nouvelle vid√©o:", error);
            });
          };
        }
      }, 200);
    }
  }
}

</script>

<style scoped>
/* D√©claration de la police Arial Rounded */
@font-face {
  font-family: 'ARIAL-ROUNDED';
  src: url('/ARLRDBD.woff') format('woff');
  font-weight: 900;
  font-style: normal;
  font-display: swap; /* Am√©liore le chargement des polices */
}

/* Styles de base */
.container {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  font-family: 'ARIAL-ROUNDED';
  background-color: #000;
}

.background-video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
  filter: brightness(0.5) blur(1px);
}

.background-audio {
  display: none;
}

/* Les styles pour le message d'orientation ont √©t√© supprim√©s */

.content {
  position: relative;
  z-index: 2;
  color: white;
  padding: 0 clamp(1rem, 5vw, 2.5rem);
  max-width: min(92%, 900px);
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  text-align: center;
  box-sizing: border-box;
}

.intro {
  margin-bottom: clamp(0.5rem, 2vw, 1.5rem);
  font-size: clamp(1.1rem, 3vw, 1.8rem);
  line-height: 1.4;
}

h2 {
  color: #fb0;
  font-weight: bold;
  margin-top: clamp(0.5rem, 1.5vw, 1.2rem);
  margin-bottom: clamp(0.2rem, 1vw, 0.7rem);
  font-size: clamp(1.3rem, 3.5vw, 2.2rem);
  width: 100%;
}

p {
  margin-bottom: clamp(0.5rem, 1.5vw, 1rem);
  font-size: clamp(0.9rem, 2.5vw, 1.5rem);
  line-height: 1.4;
  max-width: 100%;
}

/* Buttons container */
.buttons-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: clamp(0.8rem, 2vw, 1.5rem);
  margin-top: clamp(0.8rem, 2.5vw, 2rem);
  width: 100%;
}

/* Play button */
.play-btn {
  padding: clamp(0.6rem, 1.5vw, 1rem) clamp(1rem, 2vw, 2rem);
  font-size: clamp(0.9rem, 2vw, 1.3rem);
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: 2px solid white;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(5px);
  width: 100%;
  max-width: min(300px, 80%);
  text-align: center;
  margin-bottom: 0.5rem;
}

.play-btn:hover, .play-btn:active {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

/* Utopia button - avec animation d'apparition */
.utopia-btn {
  padding: clamp(0.6rem, 1.5vw, 1rem) clamp(1rem, 2vw, 2rem);
  background: linear-gradient(180deg, #ffd700, #00e1ff);
  color: #222;
  font-weight: bold;
  border: none;
  border-radius: 50px;
  cursor: pointer;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
  transition: transform 0.2s, box-shadow 0.2s;
  outline: none;
  opacity: 0.98;
  z-index: 10;
  font-family: 'ARIAL-ROUNDED';
  font-size: clamp(0.9rem, 2vw, 1.3rem);
  width: 100%;
  max-width: min(300px, 80%);
  text-align: center;
  animation: appear 0.8s ease-in-out;
  text-decoration: none;
  display: inline-block;
}

@keyframes appear {
  0% { 
    opacity: 0;
    transform: translateY(20px) scale(0.8);
  }
  100% { 
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.utopia-btn:hover, .utopia-btn:active {
  transform: scale(1.05);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

/* Desktop styles */
@media (min-width: 1200px) {
  .content {
    padding: 2rem;
  }
  
  p br {
    display: inline; /* Assure que les retours √† la ligne sont conserv√©s sur desktop */
  }
  
  .buttons-container {
    margin-top: 2rem;
  }
}

/* Tablet styles */
@media (min-width: 768px) and (max-width: 1199px) {
  .content {
    padding: 2rem;
  }
  
  p {
    text-align: center;
  }
}

/* Mobile landscape styles */
@media (max-width: 767px) and (orientation: landscape) {
  .content {
    justify-content: center;
    padding: 1.5rem;
    overflow-y: auto;
    min-height: auto;
  }
  
  p br {
    display: none; /* Supprime les retours √† la ligne pour une meilleure fluidit√© */
  }
  
  .buttons-container {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .play-btn, .utopia-btn {
    min-width: 150px;
    font-size: 0.9rem;
  }
}

/* Mobile portrait styles - Am√©lior√©s pour une exp√©rience optimale en portrait */
@media (max-width: 767px) and (orientation: portrait) {
  .content {
    text-align: center;
    padding: 1.5rem;
    justify-content: center;
    /* Ajustement pour le mode portrait */
    height: auto;
    min-height: 100vh;
    overflow-y: auto;
  }
  
  p br {
    display: none;
  }
  
  .intro {
    margin-bottom: 1rem;
    font-size: clamp(1rem, 4vw, 1.6rem);
  }
  
  h2 {
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
    font-size: clamp(1.2rem, 5vw, 2rem);
  }
  
  p {
    font-size: clamp(0.9rem, 3.5vw, 1.4rem);
  }
  
  .buttons-container {
    margin-top: 2rem;
  }
  
  /* Am√©lioration de la vid√©o en mode portrait */
  .background-video {
    object-position: center;
  }
}

/* Very small devices */
@media (max-width: 360px) {
  .content {
    padding: 1rem;
  }
  
  h2 {
    font-size: 1.2rem;
    margin-top: 0.7rem;
  }
  
  p {
    font-size: 0.9rem;
    margin-bottom: 0.4rem;
  }
  
  .play-btn, .utopia-btn {
    font-size: 0.8rem;
    padding: 0.5rem 1rem;
  }
}

/* Height-challenged devices */
@media (max-height: 500px) and (orientation: landscape) {
  .content {
    padding: 0.8rem;
    overflow-y: auto;
    justify-content: center;
  }
  
  .intro {
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
  }
  
  h2 {
    font-size: 1.1rem;
    margin-top: 0.5rem;
    margin-bottom: 0.3rem;
  }
  
  p {
    font-size: 0.8rem;
    margin-bottom: 0.3rem;
  }
  
  .buttons-container {
    margin-top: 0.5rem;
    gap: 0.5rem;
    flex-direction: row;
  }
  
  .play-btn, .utopia-btn {
    font-size: 0.8rem;
    padding: 0.4rem 0.8rem;
    min-width: auto;
  }
}

/* Pour les appareils √† √©cran large */
@media (min-width: 1600px) {
  .content {
    max-width: 1000px;
  }
  
  .intro {
    font-size: 2rem;
  }
  
  h2 {
    font-size: 2.4rem;
  }
  
  p {
    font-size: 1.6rem;
  }
}

/* Pour les appareils avec des √©crans √† ratio diff√©rent */
@media (aspect-ratio: 21/9), (min-aspect-ratio: 2/1) {
  .content {
    padding: 2rem;
    justify-content: center;
  }
  
  .background-video {
    width: 100vw;
    height: auto;
    min-height: 100vh;
  }
}

/* Pour les appareils avec √©cran tactile */
@media (hover: none) {
  .play-btn:active, .utopia-btn:active {
    transform: scale(0.95);
  }
}
</style>